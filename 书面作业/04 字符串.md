1.
KMP构造：
- 定义pi[i]为模式p[0:i]的border长度。
- 逐位计算得到：

i:      0 1 2 3 4 5 6
pi[i]:   a b a b a c a
border: 0 0 1 2 3 0 1

DFA构造：
构造状态0~m，状态k表示已经匹配k个模式字符，若达到m则表示完整匹配，对每个状态和每个字符定义dfa[state][char]为下一个状态，然后逐个递推。

KMP与DFA的联系：
- 两者都逐字符扫描并维护已匹配的模式前缀长度，若下一个字符匹配则前进，反之后退，采用相同逻辑。
- DFA是显式表，而KMP是隐式表，时间比DFA更省。

2.采用滑动窗口
```
pair<string,int> maxxsubstring(string s){
    int l=s.length();
    unordered_map<char,int>ma;
    int left=0;
    int ans=-1;
    int maxx=-1;
    for(int right=0;i<=l-1;i++){
        ma[s[right]]++;
        while(ma[s[right]]>1){
            ma[s[left]]--;
            left++;
        }
        if(right-left+1>ans){
            ans=right-left+1;
            maxx=left;
        }
    }
    auto pair<string,int>res;
    res.first=s.substr(maxx,ans);
    res.second=ans;
    return res;
};
```

3.使用双指针法，定义res为结果指针，而i为遍历指针，逐步修改即可。
```
vector<char> delete(char s){
    int r=0;
    int l=s.length();
    int i=0;
    while(i<l){
        if(s[i]=='b'){
            i++;continue;
        }
        else if(i<n-1&&s[i]=='a'&&s[i+1]=='c'){
            i+=2;
            while(res>0&&res<i){
                if(s[res-1]=='a'&&i<n&&s[i]=='c'){
                    res--;i++;
                }
                else break;
            }
        }
        else{
            s[r]=s[i];i++;r++;
        }
    }
}
```

4.先构造P的模式匹配数组pi[i]，再在与T匹配时，通过当前匹配的模式串长度，对数组进行记录。
```
vector<int>getfirstappear(string p,string t){
    int m=p.length(),n=t.length();
    int cnt=0;
    vector<int>pi(m);
    for(int i=1;i<m;i++){
        char b=p[i];
        while(cnt&&p[cnt]!=b) cnt=pi[cnt-1];
        if(p[cnt]==b) cnt++;
        pi[i]=cnt;
    }
    cnt=0;
    vector<int>res(m+1,-1);
    for(int i=0;i<n;i++){
        char b=t[i];
        while(cnt&&p[cnt]!=b) cnt=pi[cnt-1];
        if(p[cnt]==b) cnt++;
        if(res[cnt]==-1) res[cnt]=i-cnt+1;
        if(cnt==m) cnt=pi[cnt-1];
    }
    vector<int>ans(res.begin()+1,res.end());
    return ans;
}
```