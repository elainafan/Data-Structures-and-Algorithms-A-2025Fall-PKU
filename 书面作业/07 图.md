7.1
7.1.1
{<A,C>,<B,C>,<C,E>,<C,E>,<D,F>,<E,F>}

7.1.2

```c
#include<bits/stdc++.h>
using namespace std;
int n;
int x,y;
int cnt,tot;
int head[10005],ver[1005],nex[10005];
int a[10005];
int deg[1005];
void add(int x,int y){
    ver[++tot]=y;deg[y]++;
    nex[tot]=head[x],head[x]=tot;
}
void topsort(){
    queue<int>q;
    for(int i=1;i<=n;i++){
        if(deg[i]==0) q.push(i);
    }
    while(!q.empty()){
        int x=q.front();q.pop();
        a[++cnt]=x;
        for(int i=head[x];i;i=nex[i]){
            int y=ver[i];
            if(--deg[y]==0) q.push(y);
        }
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        while(cin>>x){
            if(x==0) break;
            else add(i,x);
        }
    }
    topsort();
    for(int i=1;i<=n;i++){
        cout<<a[i]<<' ';
    }
    system("pause");
    return 0;
}
```

合法的拓扑序列：``A B C D E F``

7.1.3
边``拓扑排序``边进行``DP``，答案为``11``

7.2

7.2.1
根据以下SPFA算法，求出答案

```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,tot;
int d[100005],v[100005];//v[x]表示x在不在队列中，spfa和dijkstra最大的差别就是一个是队列 另一个大根堆 用的是vis表示是否走过 且vis变为1后不会变化
int x,y,z;
int nex[100005],head[100005],ver[100005],edge[100005];
int sx;
queue<int>q;
void add(int x,int y,int z){
    ver[++tot]=y;
    edge[tot]=z;
    nex[tot]=head[x];
    head[x]=tot;
}
void spfa(int sx){
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[sx]=0;v[sx]=1;
    q.push(sx);
    while(!q.empty()){
        int x=q.front();q.pop();
        v[x]=0;
        for(int i=head[x];i;i=nex[i]){
            int y=ver[i],z=edge[i];
            if(d[y]>d[x]+z){
                d[y]=d[x]+z;
                if(!v[y]){
                    q.push(y);
                    v[y]=1;
                }
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
    }
    scanf("%d",&sx);
    spfa(sx);
    for(int i=1;i<=n;i++){
        printf("%d ",d[i]);
    }
    system("pause");
    return 0;
}
```

即 ``d[A]=2,d[B]=4,d[C]=5,d[D]=3``

7.2.2
还是用SPFA算法，由以下算法，判断出没有负环

```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t,n,m,tot;
int u,v,w;
int head[20005],nex[20005],ver[20005],edge[20005];
int cnt[20005],vis[20005],d[20005];
void add(int x,int y,int z){
    ver[++tot]=y;
    edge[tot]=z;
    nex[tot]=head[x];
    head[x]=tot;
}
void spfa(int sx){
    queue<int>q;
    d[sx]=0,vis[sx]=1,cnt[sx]=1;
    q.push(sx);
    while(!q.empty()){
        int x=q.front();q.pop();
        vis[x]=0;
        for(int i=head[x];i;i=nex[i]){
            int y=ver[i],z=edge[i];
            if(d[y]>d[x]+z){
                d[y]=d[x]+z;
                if(!vis[y]){
                    cnt[y]++;
                    if(cnt[y]>=n){//这里判断的应该是入队次数而不是松弛次数
                        printf("YES\n");
                        return ;
                    }
                    vis[y]=1;
                    q.push(y);
                }
            }
        }
    }
    printf("NO\n");
}
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&n,&m);
        memset(head,0,sizeof(head));
        memset(nex,0,sizeof(nex));
        memset(ver,0,sizeof(ver));
        memset(edge,0,sizeof(edge));
        memset(cnt,0,sizeof(cnt));
        memset(vis,0,sizeof(vis));
        memset(d,0x3f,sizeof(d));
        tot=0;
        for(int i=1;i<=m;i++){
            scanf("%d%d%d",&u,&v,&w);
            if(w>=0){
                add(u,v,w);
                add(v,u,w);
            }
            else{
                add(u,v,w);
            }
        }
        spfa(1);
    }
    system("pause");
    return 0;
}
```

7.3

7.3.1 
每次选入的边：<D,E>,<D,F>,<B,C>,<A,C>,<C,D>

7.3.2 
总权值为11

7.3.3
维护到 $ 2^i $ 级祖先路径上的最大边权的同时维护严格次大边权，当用于替换的边的权值与原生成树中路径最大边权相等时，我们用严格次大值来替换即可。

这个过程可以用倍增求解，复杂度 $O(m \log m)$ 。

```c
#include <algorithm>
#include <iostream>

constexpr int INF = 0x3fffffff;
constexpr long long INF64 = 0x3fffffffffffffffLL;

struct Edge {
  int u, v, val;

  bool operator<(const Edge &other) const { return val < other.val; }
};

Edge e[300010];
bool used[300010];

int n, m;
long long sum;

class Tr {
 private:
  struct Edge {
    int to, nxt, val;
  } e[600010];

  int cnt, head[100010];

  int pnt[100010][22];
  int dpth[100010];
  // 到祖先的路径上边权最大的边
  int maxx[100010][22];
  // 到祖先的路径上边权次大的边，若不存在则为 -INF
  int minn[100010][22];

 public:
  void addedge(int u, int v, int val) {
    e[++cnt] = Edge{v, head[u], val};
    head[u] = cnt;
  }

  void insedge(int u, int v, int val) {
    addedge(u, v, val);
    addedge(v, u, val);
  }

  void dfs(int now, int fa) {
    dpth[now] = dpth[fa] + 1;
    pnt[now][0] = fa;
    minn[now][0] = -INF;
    for (int i = 1; (1 << i) <= dpth[now]; i++) {
      pnt[now][i] = pnt[pnt[now][i - 1]][i - 1];
      int kk[4] = {maxx[now][i - 1], maxx[pnt[now][i - 1]][i - 1],
                   minn[now][i - 1], minn[pnt[now][i - 1]][i - 1]};
      // 从四个值中取得最大值
      std::sort(kk, kk + 4);
      maxx[now][i] = kk[3];
      // 取得严格次大值
      int ptr = 2;
      while (ptr >= 0 && kk[ptr] == kk[3]) ptr--;
      minn[now][i] = (ptr == -1 ? -INF : kk[ptr]);
    }

    for (int i = head[now]; i; i = e[i].nxt) {
      if (e[i].to != fa) {
        maxx[e[i].to][0] = e[i].val;
        dfs(e[i].to, now);
      }
    }
  }

  int lca(int a, int b) {
    if (dpth[a] < dpth[b]) std::swap(a, b);

    for (int i = 21; i >= 0; i--)
      if (dpth[pnt[a][i]] >= dpth[b]) a = pnt[a][i];

    if (a == b) return a;

    for (int i = 21; i >= 0; i--) {
      if (pnt[a][i] != pnt[b][i]) {
        a = pnt[a][i];
        b = pnt[b][i];
      }
    }
    return pnt[a][0];
  }

  int query(int a, int b, int val) {
    int res = -INF;
    for (int i = 21; i >= 0; i--) {
      if (dpth[pnt[a][i]] >= dpth[b]) {
        if (val != maxx[a][i])
          res = std::max(res, maxx[a][i]);
        else
          res = std::max(res, minn[a][i]);
        a = pnt[a][i];
      }
    }
    return res;
  }
} tr;

int fa[100010];

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

void Kruskal() {
  int tot = 0;
  std::sort(e + 1, e + m + 1);
  for (int i = 1; i <= n; i++) fa[i] = i;

  for (int i = 1; i <= m; i++) {
    int a = find(e[i].u);
    int b = find(e[i].v);
    if (a != b) {
      fa[a] = b;
      tot++;
      tr.insedge(e[i].u, e[i].v, e[i].val);
      sum += e[i].val;
      used[i] = true;
    }
    if (tot == n - 1) break;
  }
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  std::cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int u, v, val;
    std::cin >> u >> v >> val;
    e[i] = Edge{u, v, val};
  }

  Kruskal();
  long long ans = INF64;
  tr.dfs(1, 0);

  for (int i = 1; i <= m; i++) {
    if (!used[i]) {
      int _lca = tr.lca(e[i].u, e[i].v);
      // 找到路径上不等于 e[i].val 的最大边权
      long long tmpa = tr.query(e[i].u, _lca, e[i].val);
      long long tmpb = tr.query(e[i].v, _lca, e[i].val);
      // 这样的边可能不存在，只在这样的边存在时更新答案
      if (std::max(tmpa, tmpb) > -INF)
        ans = std::min(ans, sum - std::max(tmpa, tmpb) + e[i].val);
    }
  }
  // 次小生成树不存在时输出 -1
  std::cout << (ans == INF64 ? -1 : ans) << '\n';
  return 0;
}
```