## 作业
1.

(1)

```
A
  B
    E
      H
      I
    F
      J
  C
  D
    G
```

A(B(E(H,I),F(J)),C,D(G))

(2)

树的高度为 $4$

伪代码

```
function getTreeHeight(node):
    // 若节点无子女，高度为1
    if node没有子节点:
        return 1
    max_sub_height = 0
    // 遍历所有子节点，取子树高度的最大值
    for 每个子节点 child in node的子节点列表:
        sub_height = getTreeHeight(child)
        if sub_height > max_sub_height:
            max_sub_height = sub_height
    // 当前节点高度 = 最大子树高度 + 1
    return max_sub_height + 1
```

(3)

先序遍历序列：``A → B → E → H → I → F → J → C → D → G``

2.

(1) 

下限为 $\sum\limits_{i=0}^{L-2} k^{i}+1=\frac{k^{L-1}+K-2}{K-1}$

上限为满，即 $\sum\limits_{i=0}^{L-1} k^i=\frac{K^L-1}{K-1}$

(2)

父节点编号为 $\lfloor \frac{n-1}{K} \rfloor$

(3)

节点 $n$ 的第 $i$ 个子节点的编号为 $(n-1) \times K +i +1$

(4)

存在条件：该节点不是其父节点的第 $K$ 个孩子，并且它右侧还有编号，并且它有父节点

即 $n \mathrm{mod} K \not ={1},n \geq 2,n+1 \leq N$ 

3.

(1)

```
[0,0,0,0,3,0,0,6,6,9]
```

(2) 设每次合并的树的规模分别为 $m,n$, 有 $m \leq n$

则合并后树的规模至少为 $m+n \geq 2m$

意味着，一个节点所在树的规模每次至少翻倍，设树的高度为 $h$, 则规模 $S \geq 2^h$

于是 $2^h \leq N$ ，即 $h \leq \log_{2} n$ ，因此树的高度为 $O(\log N)$

## 补充习题

1.

```cpp
template<class T>
void MirrorReverse(TreeNode<T>* root){
    if(!root) return ;
    reverse(root->children.begin(),root->children.end());
    for(auto p:root->children){
        reverse(p);
    }
}
```

2.

```cpp
template<class T>
void ltagrlink-Seq(Ltag-rlinkTreeNode<T> *nodeArray,TreeNode<T>* root){
    if(!root) return ;
    cout<<nodeArray[root].info<<" ";
    if(nodeArray[root].ltag==0){
        LtagRlinkSeq(nodeArray,root->left);
    }
    LtagRlinkSeq(nodeArray,nodeArray[root].rlink);
}
```