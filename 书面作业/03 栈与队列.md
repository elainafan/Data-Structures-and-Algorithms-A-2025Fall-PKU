1.
```
stack<int>s;
void push(int x){
  if(mix==INT_MIN){
    s.push(x);
    s.push(x);  
  } 
  else{
    int mixx=s.top();
    s.push(x);
    s.push(min(x,mixx));
  }
  return ;
}
int pop(){
    s.pop();
    int x=s.top();s.pop();
    return x;
}
int top(){
    int node=s.top();
    s.pop();
    int node_2=s.top();
    s.push(node);
    return node_2;
}
int getMin(){
    return s.top();
}
```
2.火车进站相当于进栈出栈。

采用离散数学中的非降序列原理。

假设为 $(0,0)$ 到 $(n,n)$ 的路径，假设从 $y=x+1$ 上的一点P离开。

沿着 $y=x+1$ 进行翻转，生成新的一段从 $(-1,1)$ 到P的非降路径，用这条路径替换原有路径的前半段，得到从 $(-1,1)$ 到 $(n,n)$ 的非降路径，并且与原有路径一一对应，得到答案 $\frac{1}{n+1}\dbinom{2n}{n}$ 

3.(1). 
- 每执行一个新操作x，S1.push(x)。
- 每撤销一步操作，取x=S1.top(),S1.pop(),S2.push(x)。
- 每恢复一步操作，取x=S2.top(),S2.pop(),S1.push(x)。

(2)
S1:A,B,D

S2:空

4.(1).
Push(x):enQueue(Q1,x)
Pop:
```
while(isEmpty(Q1)){
    auto node=deQueue(Q1);
    enQueue(Q2,node);
}
auto node=deQueue(Q2);
while(isEmpty(Q2)){
    auto node=deQueue(Q2);
    enQueue(Q1,node);
}
```

(2).
Push:O(1)

Pop:O(n)

(3).
第一次：3

第二次：4

第三次：2